#include <iostream>
#include <iomanip>
#include <fstream>
#include <stdlib.h>
#include <time.h>
#include<cstring>
#include<cstdio>
#include<vector>
#include<string>
#include<algorithm>
#include <limits.h>
#include<cmath>
#include<map>
#include<queue>
#include<set>
using namespace std;


#define LL long long
#define N 11111
const long long  mod =1000000007;  //这个必须是质数
int Rank[N],height[N];
char s[N];

//原数组为s[N]

int sa[N],t[N],t2[N],c[N];

// 每个字符值必须为0--(m-1)


void build_sa(char *s,int n,int m) {
    int i,*x=t,*y=t2;
    for (i=0; i<m; i++) c[i]=0;
    for (i=0; i<n; i++) c[x[i]=s[i]]++;
    for (i=1; i<m; i++) c[i]+=c[i-1];
    for (i=n-1; i>=0; i--)
        sa[--c[x[i]]]=i;
    for (int k=1; k<=n; k<<=1) {
        int p=0;
        for (i=n-k; i<n; i++) y[p++]=i;
        for (i=0; i<n; i++) if (sa[i]>=k) y[p++]=sa[i]-k;
        for (i=0; i<m; i++) c[i]=0;
        for (i=0; i<n; i++) c[x[y[i]]]++;
        for (i=0; i<m; i++) c[i]+=c[i-1];
        for (i=n-1; i>=0; i--) sa[--c[x[y[i]]]]=y[i];
        swap(x,y);
        p=1;
        x[sa[0]]=0;
        for (i=1; i<n; i++)
            x[sa[i]]=y[sa[i-1]]==y[sa[i]]&&y[sa[i-1]+k]==y[sa[i]+k]?p-1:p++;
        if (p>=n) break;
        m=p;
    }
}
void calheight_and_rank(char *r,int n) {
    int i,j,k=0;
    for(i=0; i<n; i++) Rank[sa[i]]=i;
    for (i=0;i<n;i++){
        if (k) k--;
        if (Rank[i]){
            int j=sa[Rank[i]-1];
            while (s[i+k]==s[j+k]) k++;
        }
        height[Rank[i]]=k;
    }
    return;
}

int main()
{
    scanf("%s",s);
    int n=strlen(s);
    s[n++]='a'-1;
    build_sa(s,n,'z'+1);
    calheight_and_rank(s,n);
    return 0;
}


//注意二分时不能以height[i]<len作为分割线，因为最后的可能出现连续大于len的情况
//一般参考下面的写法
bool suan(int len,int K,int n) {
    int sum=1;
    for (int j=1; j<n; j++) {
        if (height[j]>=len) {
            sum++;
            if (sum>=K) return true;

        }else sum=1;
    }
    return false;
}