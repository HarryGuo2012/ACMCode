#include <iostream>
#include <iomanip>
#include <fstream>
#include <stdlib.h>
#include <time.h>
#include<cstring>
#include<cstdio>
#include<vector>
#include<string>
#include<algorithm>
#include <limits.h>
#include<cmath>
#include<map>
#include<queue>
#include<set>
#include<iosfwd>
using namespace std;

class bign
{
public:
	int len, s[1000];
	bign();
	bign(const char*);
	bign(int);
	string toStr() const;
	bign operator=(const char*);
	bign operator=(int);
	bool operator>(const bign &) const;
	bool operator>=(const bign &) const;
	bool operator<(const bign &) const;
	bool operator<=(const bign &) const;
	bool operator==(const bign &) const;
	bool operator!=(const bign &) const;
	bign operator+(const bign &) const;
	bign operator++();
	bign operator++(int);
	bign operator+=(const bign&);
	bign operator-(const bign &) const;
	bign operator--();
	bign operator--(int);
	bign operator-=(const bign&);
	bign operator*(const bign &)const;
	bign operator*(const int num)const;
	bign operator*=(const bign&);
	bign operator/(const bign&)const;
	bign pow(const bign&)const;
	void clean();
	~bign();
};


bign operator*(const int& a, const bign& b) {
    return b*a;
}

bign::bign()
{
	memset(s, 0, sizeof(s));
	len = 1;
}

bign::bign(const char *num)
{
	*this = num;
}

bign::bign(int num)
{
	*this = num;
}

string bign::toStr() const
{
	string res = "";
	for (int i = 0; i < len; i++)
	{
            res = (char)(s[i] + '0') + res;
	}
	if (res == "")
		res = "0";
	return res;
}

bign bign::operator=(const char *num)
{
	memset(s, 0, sizeof(s));
	len = strlen(num);
	for (int i = 0; i < len; i++)
		s[i] = num[len - i - 1] - 48;
	return *this;
}

bign bign::operator=(int num)
{
	char temp[1000];
	sprintf(temp, "%d", num);
	*this = temp;
	return *this;
}


bool bign::operator<(const bign &num) const
{
	if (len != num.len)
		return len < num.len;
	for (int i = len - 1; i >= 0; i--)
		if (s[i] != num.s[i])
			return s[i] < num.s[i];
	return false;
}

bool bign::operator>(const bign&num)const
{
	return num < *this;
}

bool bign::operator<=(const bign&num)const
{
	return !(*this>num);
}

bool bign::operator!=(const bign&num)const
{
	return *this > num || *this < num;
}

bool bign::operator==(const bign&num)const
{
	return !(num != *this);
}

bign bign::operator+(const bign &num) const
{
	bign result;
	result.len = 0;
	int temp = 0;
	for (int i = 0; temp || i < (max(len, num.len)); i++)
	{
		int t = s[i] + num.s[i] + temp;
		result.s[result.len++] = t % 10;
		temp = t / 10;
	}
	return result;
}

bign bign::operator++()
{
	*this = *this + 1;
	return *this;
}

bign bign::operator++(int)
{
	bign old = *this;
	++(*this);
	return old;
}

bign bign::operator+=(const bign &num)
{
	*this = *this + num;
	return *this;
}

bign bign::operator-(const bign &num) const
{
	bign result;
	result.len = 0;
	for (int i = 0, g = 0; i < len; i++)
	{
		int x = s[i] - g;
		if (i < num.len) x -= num.s[i];
		if (x >= 0) g = 0;
		else
		{
			g = 1;
			x += 10;
		}
		result.s[result.len++] = x;
	}
	result.clean();
	return result;
}

bign bign::operator * (const bign &num)const
{
	bign result;
	result.len = len + num.len;

	for (int i = 0; i < len; i++)
		for (int j = 0; j < num.len; j++)
			result.s[i + j] += s[i] * num.s[j];

	for(int i = 0; i < result.len; i++)
	{
		result.s[i + 1] += result.s[i] / 10;
		result.s[i] %= 10;
	}
	result.clean();
	return result;
}

bign bign::operator*(const int num)const
{
	bign x=num;
	bign z=*this;
	return x*z;
}
bign bign::operator*=(const bign&num)
{
	*this=*this * num;
	return *this;
}

bign bign::operator /(const bign&num)const
{
	bign ans;
	ans.len=len-num.len+1;
	if (ans.len<0) {
		ans.len=1;
		return ans;
	}
	bign chu=*this;
	int k=ans.len-1;
	int j=len-1;
	while  (k>=0){
		while (chu.s[j]==0) j--;
		if (k>j) k=j;
		char z[1000];
		memset(z,0,sizeof(z));
		for (int i=j;i>=k;i--)
			z[j-i]=chu.s[i]+'0';
		bign chushu=z;
		if (chushu<num) {k--;continue;}
		int key=0;
		while (num*key<=chushu) key++;
		key--;
		ans.s[k]=key;
		bign temp=num*key;
		for (int i=0;i<k;i++)
			 temp=temp*10;
		chu=chu-temp;
		k--;
	}
	ans.clean();
	return ans;
}
bign bign::pow(const bign& num)const
{
	bign result = 1;
	for (bign i = 0; i<num; i++)
		result = result*(*this);
	return result;
}

void bign::clean()
{
	if (len==0) len++;
	while (len>1 && s[len - 1] == '\0')
		len--;
}

bign::~bign()
{
}
